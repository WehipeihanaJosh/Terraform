parameters:
  - name: environmentName
    type: string
  - name: serviceName
    type: string
  - name: locationCode
    type: string

jobs:
  - deployment: apply_${{ parameters.serviceName }}_${{ parameters.locationCode }}_${{ parameters.environmentName }}
    pool:
      vmImage: ubuntu-latest
    variables:
      - template: ../variables/${{ parameters.environmentName }}.job.vars.yml
    environment: "Environment_${{ parameters.serviceName }}_${{ parameters.locationCode }}_${{ parameters.environmentName }}"
    strategy:
      runOnce:
        deploy:
          steps:
            # fetch credentials from Az CLI into environment vars
            - template: ../tasks/terraform_creds_task.yml
              parameters:
                azureSubscriptionName: ${{ variables.AzureRMServiceConnection}}
            # The Terraform code is checked out even though this is a deployment job
            # In theory could just take the tfplan from the build stage, but seems better
            # to first check if there are changes in the environment
            # TODO a future check would be to compare between the plan and apply stages
            # this would need to compare the json output as the binary tfplan is different
            # even when the changes to be done are the same
            - checkout: self
              clean: true                
            # terraform init
            - template: ../tasks/terraform_init_azurebackend_task.yml
              parameters:
                tfstateResourceGroupName: ${{ variables.tfstateResourceGroupName}}
                tfstateStorageAccountName: ${{ variables.tfstateStorageAccountName}}
                tfstateStorageContainerName: ${{ variables.tfstateStorageContainerName}}
            # terraform validate
            - template: ../tasks/terraform_validate_task.yml
            # terraform apply
            - template: ../tasks/terraform_apply_task.yml
              parameters:
                environmentTFVARS: ${{ variables.environmentTFVARS}}
